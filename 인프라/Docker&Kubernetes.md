
<br>

# 가상화의 발전 과정
- 전통적인 배포 시대
    - 초기 조직은 애플리케이션을 물리 서버에서 실행
    - 한 물리 서버에서 여러 애플리케이션의 리소스 한계를 정의할 방법이 없었기에, 리소스 할당의 문제 발생
    - 물리 서버 하나에서 여러 애플리케이션을 실행하면, 리소스를 과다 사용하는 인스턴스가 다른 애플리케이션의 성능이 저하 유발
    - 서로 다른 여러 물리 서버에서 각 애플리케이션을 실행하는 것은 리소스가 충분히 활용되지 않으며, 유지 비용 과다
- 가상화된 배포 시대
    - 단일 물리 서버의 CPU에서 여러 가상 시스템 (Virtual Machine, VM)을 실행
    - VM간에 애플리케이션을 격리하고 애플리케이션의 정보를 다른 애플리케이션에서 자유롭게 액세스 할 수 없으므로, 일정 수준의 보안성을 제공
    - 리소스를 보다 효율적으로 활용할 수 있으며, 쉽게 애플리케이션을 추가하거나 업데이트할 수 있고 하드웨어 비용을 절감할 수 있어 더 나은 확장성 제공
    - 가상화를 통해 일련의 물리 리소스를 폐기 가능한(disposable) 가상 머신으로 구성된 클러스터로 구성 가능
    - 각 가상 머신은 가상화된 하드웨어 상에서 자체 운영체제를 포함한 모든 구성 요소를 실행하는 하나의 완전한 머신
![가상화의 발전](https://itwiki.kr/images/thumb/d/d4/%EA%B0%80%EC%83%81%ED%99%94%EC%9D%98_%EB%B0%9C%EC%A0%84_%EA%B3%BC%EC%A0%95.png/800px-%EA%B0%80%EC%83%81%ED%99%94%EC%9D%98_%EB%B0%9C%EC%A0%84_%EA%B3%BC%EC%A0%95.png?20200920093921)
- 컨테이너 개발 시대
    - 컨테이너는 VM과 유사하지만 격리 속성을 완화하여 애플리케이션 간에 운영체제(OS)를 공유하므로 각각의 컨테이너는 보다 가벼움

<br>

# Docker의 역사
- 도커는 2013년 3월 산타클라라에서 열린 Pycon Conference에서 dotCloud의 창업자인 Solomon Hykes가 `The future of Linux Containers`라는 세션을 발표하며 알려짐
- 이 발표 이후 도커가 인기를 얻으면서 회사이름을 도커로 바꾸는 등 도커에 집중함
- 2016년 6월 마이크로소프트에서 4조원에 도커 회사를 인수

<br>

# Docker란?
- 컨테이너 기반의 오픈소스 가상화 플랫폼
- 다양한 프로그램, 실행환경을 컨테이너로 추상화하고 동일한 인터페이스를 제공하여 프로그램의 배포 및 관리를 단순하게 해줌
- 백엔드 프로그램, DB 서버, 메시지 큐 등 어떤 프로그램이든 컨테이너로 추상화할 수 있고 어떤 환경에서든 실행할 수 있음

## 기존 가상 머신과의 차이
- 가상머신
    - 하드웨어 레벨 가상화
    - 가상 하드웨어 환경 위에서 게스트 OS 설치
- 도커 컨테이너
    - OS 레벨 가상화
    - 컨테이너 엔진으로 어플리케이션 실행 환경 격리

![도커와가상머신차이](https://itwiki.kr/images/8/85/%EA%B0%80%EC%83%81_%EB%A8%B8%EC%8B%A0%EA%B3%BC_%EC%BB%A8%ED%85%8C%EC%9D%B4%EB%84%88.png)

## 장단점
- 장점
    - 속도 빠름
    - 이미지 생성 및 공유 쉬움
    - 단일 어플리케이션 구동을 위한 최소한의 환경만 구분함
- 단점
    - 가상머신 방식처럼 다양한 OS를 사용할 수 없음(오직 리눅스 바탕)
    - 보안적으로 완전히 격리되지 않음 (DinD, DooD)

## 도커의 구조
![도커의구조](https://velog.velcdn.com/images/sorzzzzy/post/0a976516-ee69-4fe4-9223-513d5e885a56/image.png)

- 호스트 운영체제 위에 도커 엔진이 실행되고 도커 엔진 위에 컨테이너들이 실행되는 구조
- 컨테이너 기술은 리눅스의 컨테이너(LXC)를 활용한 기술로 컴퓨터에 독립적인 컴퓨팅 공간을 만들어냄
- 도커는 컨테이너라는 가상의 격리 환경을 만들기 위해 리눅스의 `namespace`와 `cgroup`이라는 기능을 사용함(namespace와 cgroup으로 만들어진 컨테이너를 LXC라고 부름)
    - namespace : 프로세스를 독립시켜주는 가상화 기술, 각 컨테이너에서 실행된 프로세스가 시스템 등에 대해 독립할 수 있게 해줌
    - cgroups : 자원에 대한 제어를 가능하게 해주는 리눅스 커널의 기능

<br>

# 쿠버네티스란
- 쿠버네티스는 컨테이너화된 워크로드와 서비스를 관리하기 위한 이식성이 있고, 확장가능한 오픈소스 플랫폼
- 구글이 2014년에 쿠버네티스 프로젝트를 오픈소스화함

## 왜 필요하고 무엇을 할 수 있는지
- 프로덕션 환경에서는 컨테이너가 다운되면 컨테이너를 다시 시작해야 하는 등 컨테이너를 관리하고 상태를 모니터링해야 한다.
- 위와 같은 상황을 자동으로 처리해주는 것이 쿠버네티스의 역할
- 쿠버네티스는 분산 시스템을 탄력적으로 실행하기 위한 프레임 워크를 제공함
- 애플리케이션의 확장과 장애 조치를 처리하고 배포 패턴 등을 제공

## 제공하는 기능
- 서비스 디스커버리와 로드 밸런싱
    - DNS 이름을 사용하거나 자체 IP 주소를 사용해 컨테이너를 노출 할 수 있음. 컨테이너에 대한 트래픽이 많으면 네트워크 트래픽을 로드밸런싱하고 배포하여 안정적으로 유지할 수 있음
- 스토리지 오케스트레이션
    - 로컬 저장소나 공용 클라우드 공급자 등과 같이 원하는 저장소 시스템을 자동으로 탑재 할 수 있음
- 자동화된 롤아웃과 롤백
    - 쿠버네티스를 사용하여 배포된 컨테이너의 원하는 상태를 서술할 수 있으며 현재 상태를 원하는 상태로 설정한 속도에 따라 변경할 수 있음 (ex - 쿠버네티스를 자동화해서 배포용 새 컨테이너를 만들고 기존 컨테이너를 제거하고, 모든 리소스를 새 컨테이너에 적용)
- 자동화된 빈 패킹(bin packing)
    - 컨테이너화된 작업을 실행하는데 사용할 수 있는 쿠버네티스 클러스터 노드를 제공, 각 컨테이너가 필요로 하는 CPU와 메모리를 쿠버네티스에게 지시, 쿠버네티스는 컨테이너를 노드에 맞추어서 리소스를 가장 잘 사용할 수 있도록 해줌
- 자동화된 복구
    - 실패한 컨테이너를 다시 시작하고 컨테이너를 교체하며 사용자 정의 상태 검사에 응답하지 않는 컨테이너를 죽이고 서비스 준비가 끝날 때까지 그러한 과정을 클라이언트에 보여주지 않음
- 시크릿과 구성 관리
    - 쿠버네티스를 사용하면 암호, OAuth 토큰 및 SSH 키와 같은 중요한 정보를 저장하고 관리할 수 있음, 컨테이너 이미지를 재구성하지 않고 스택 구성에 시크릿을 노출하지 않고도 시크릿 및 애플리케이션 구성을 배포 및 업데이트 가능

## 핵심 개념
- 계속해서 원하는 상태를 만들기 위해 현재 상태를 바꿔줌
![상태](https://img1.daumcdn.net/thumb/R1280x0/?scode=mtistory2&fname=https%3A%2F%2Fblog.kakaocdn.net%2Fdn%2FcOou5p%2FbtqFDwLCI49%2F0b9LcF2HNCVXhCEwzm8Gw1%2Fimg.png)

- Desired State
    - 사용자가 원하는 상태
- Current State
    - 현재 쿠버네티스의 상태
